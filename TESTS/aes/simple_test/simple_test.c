/* Copyright 2020 University of Adelaide
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *    http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

volatile uint8_t tmpout[16];
volatile uint8_t tmpfake[16];

extern uint8_t output[16];

typedef struct _Test
{
    uint8_t input[16];
    uint8_t output[16];
    uint8_t key[32];
    int keylen;
}Test;

Test tests[] = 
{
    {
        .input = {0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a},
        .output = {0x3a,0xd7,0x7b,0xb4,0x0d,0x7a,0x36,0x60,0xa8,0x9e,0xca,0xf3,0x24,0x66,0xef,0x97},
        .key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c},
        .keylen = 128 
    },
    {
        .input = {0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51},
        .output = {0xf5,0xd3,0xd5,0x85,0x03,0xb9,0x69,0x9d,0xe7,0x85,0x89,0x5a,0x96,0xfd,0xba,0xaf},
        .key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c},
        .keylen = 128 
    },
    {
        .input = {0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef},
        .output = {0x43,0xb1,0xcd,0x7f,0x59,0x8e,0xce,0x23,0x88,0x1b,0x00,0xe3,0xed,0x03,0x06,0x88},
        .key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c},
        .keylen = 128 
    },
    {
        .input = {0x00, 0x03, 0x65, 0x87, 0x83, 0x4b, 0xc6, 0xe4, 0x22, 0x33, 0x56, 0x76, 0x9f, 0xff, 0xdf, 0xff },
        .output = {0x08, 0x64, 0x04, 0xcd, 0x7c, 0x74, 0x9c, 0x89, 0x00, 0x13, 0x42, 0x6d, 0xc4, 0x86, 0x2e, 0xe2 },
        .key = {0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0x12,0x34,0x56,0x78,0x9A,0xBC,0xDE,0xF0},
        .keylen = 128
    },
    {
        .input = {0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10},
        .output = {0x7b,0x0c,0x78,0x5e,0x27,0xe8,0xad,0x3f,0x82,0x23,0x20,0x71,0x04,0x72,0x5d,0xd4},
        .key = {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c},
        .keylen = 128 
    }
};
//void run_aes_masked(uint8_t* inputbuf, uint8_t* keybuf, uint8_t* outputbuf, uint8_t* randombuf);
void run_byte_aes_masked_(uint8_t* inputbuf, uint8_t* keybuf);

#define TEST_FUNC(...)  \
    run_byte_aes_masked_(__VA_ARGS__)
int main()
{
    srand(time(NULL));
    
    int fail = 0;
    for (int i=0;i<sizeof(tests)/sizeof(Test);i++)
    {
        TEST_FUNC(tests[i].input, tests[i].key);
        if (memcmp(output, tests[i].output, 16) != 0)
	{
	    int j=0;
	    for (j=0;j<16;j++)
	    {
		printf("0x%02x, ",output[j]);
	    }
	    printf("\n");
            fail = 1; 
	}
    }
    printf("%s\n",fail ? "fail" : "pass");
    return 0;
}

